package net.dwarfguide.model.core;

/*Generated by MPS */

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.apache.commons.io.FileUtils;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.io.InputStream;
import org.simpleframework.xml.stream.Format;
import org.simpleframework.xml.stream.CamelCaseStyle;
import org.simpleframework.xml.strategy.Strategy;
import org.simpleframework.xml.convert.AnnotationStrategy;
import org.simpleframework.xml.transform.RegistryMatcher;
import org.simpleframework.xml.Serializer;
import org.simpleframework.xml.core.Persister;


/**
 * * @author Dmitry Sidorenko
 */
public class CreatureRunesmithLoader implements CreatureLoader {
  protected static Log log = LogFactory.getLog(CreatureRunesmithLoader.class);

  private String myXmlFile;

  public CreatureRunesmithLoader(@XMLFile String xmlFile) {
    this.setXmlFile(xmlFile);
  }

  @Override
  public List<Creature> loadCreatures() {
    try {
      return ListSequence.fromList(deserialize(FileUtils.openInputStream(new File(this.getXmlFile())))).select(new ISelector<CreatureXML, Creature>() {
        public Creature select(final CreatureXML it) {
          return it.toCreature();
        }
      }).toListSequence();
    } catch (Exception exception) {
      if (log.isErrorEnabled()) {
        log.error("Error deserializing", exception);
      }
      return ListSequence.fromList(new LinkedList<Creature>());
    }
  }

  private List<CreatureXML> deserialize(InputStream in) throws Exception {
    Format format = new Format(new CamelCaseStyle(true));
    Strategy strategy = new AnnotationStrategy();
    RegistryMatcher matcher = new RegistryMatcher();
    registerEnumTransform(matcher, Sex.class);
    registerEnumTransform(matcher, ProfessionEnum.class);
    registerEnumTransform(matcher, TraitEnum.class);
    registerEnumTransform(matcher, SkillEnum.class);

    Serializer serializer = new Persister(strategy, matcher, format);
    return serializer.read(Creatures.class, in).getCreatures();
  }

  public <T extends Enum<T>> void registerEnumTransform(RegistryMatcher matcher, Class<T> enumClass) {
    matcher.bind(enumClass, new CreatureRunesmithLoader.EnumTransform<T>(enumClass));
  }

  public String getXmlFile() {
    return this.myXmlFile;
  }

  private void setXmlFile(String value) {
    this.myXmlFile = value;
  }

  private static class EnumTransform<EnumType extends Enum<EnumType>> extends ReadonlyTransform<EnumType> {
    private Class<EnumType> typeClass;

    private EnumTransform(Class<EnumType> typeClass) {
      this.typeClass = typeClass;
    }

    @Override
    public EnumType read(String value) throws Exception {
      return Enum.valueOf(typeClass, value.toUpperCase().replaceAll("\\W", "_"));
    }
  }

  private class TraitTransform extends ReadonlyTransform<TraitInstance> {
    public TraitTransform() {
    }

    @Override
    public TraitInstance read(String descr) throws Exception {
      return TraitDecoder.findByName(descr);
    }
  }
}
